---
title: 인턴 면접
date: 2017-03-12 19:04:51
tags:
- google
- ps
- C++
---
3/10, 인턴 면접을 보았다.
나는 인턴 면접도 ps 형식으로 나올 것으로 기대하고, 열심히 ps를 했었다.
그런데 웬걸..
완전 구현 문제 위주였다 ㅠㅠ
<!-- more -->

### 면접 1
왕위 계승이 [부모 &rarr; 첫번째 자식 &rarr; 첫번째 손자 &rarr; ... &rarr; 둘째 자식]의 순으로 이루어질 때, 다음을 구현하라.

```C++
mornarchy{
    void birth(string parent, string child);
    void death(string name);
    vector<string> priority(); // 이 함수 interface는 기억이 잘 나지 않는다.
}
```

왕위 계승 순서에 대하여는, 트리를 만들고 inorder 순회를 하면 된다.
단, 죽은 자에 대해서는 죽은 자의 자식에 대하여 substitute를 통해서 최적화를 시도할 수 있다.
이 부분까지는 크게 막힘 없이 접근 했었다..

그런데...

자식을 관리하는 걸 `vector<string>`으로 해야겠어요! 라고 했다가 갑자기,
그런데 `stack<string>` 두 개를 들고 있으면 좋을 것 같아요...
잠시만요..
이러면서 삽질을 하다가 결국 시간을 많이 버렸다.

그러고 나서는 트리의 노드를 구현할 때 부모를 들고 있어야 하는걸 까먹고..
또 `new`로 memory allocate를 할 때 주소로 나온다는걸 까먹고...

이러다가 시간을 다 버리고 코드는 반도 못 쓰고 망했다고 한다..

### 면접 2
[Conway's Game of Life](https://en.wikipedia.org/wiki/Conway's_Game_of_Life).

규칙은 위키 링크의 그것과 동일하다.

1. Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.
1. Any live cell with two or three live neighbours lives on to the next generation.
1. Any live cell with more than three live neighbours dies, as if by overpopulation.
1. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

이럴 때, n*n의 현재 생존 정보가 들어올 때, 다음 세대에 어떻게 될 지 계산하도록 해야했다.

직전 시간에 메모리 때문에 당황하다가 시간을 날려버렸고,
이 시간 문제에는 함수의 형태에 대해서 지정해주지 않았기 때문에,
그냥 인자로 현재 세대 life에 대한 2차원 배열과, 출력을 받을 2차원 배열을 같이 받았다.

O(n^2)이 나올거 같은데, 이걸 좀 더 줄여볼 수 있을 것도 같다고 하니,
어차피 그래도 많이 안 줄지 않냐고 해서,
"네, 그래도 계수 정도는 줄일 수 있을 것 같아요"라고 했다.
그래도 O(n^2)이지 않냐고 하셔서 그냥 짜기 시작함.

코드를 깔끔하게 짜기 위해서 적당히 손질을 좀 했고,
다 짜고 나서도 대충 10분은 남았던 것 같다.
고칠 부분이 있냐고 하길래 if-else문이 3개로 된 걸 2개로 고쳤고,
상수를 줄이기 위해서 주변 8개를 매번 새로 읽지 않고 저장해놓는 방식을 고안해봤다.
물론 이 경우 당연히 큰 이득은 없을 것이라고 했고,
규칙이 바뀌어서 주변 8개가 아니라 더 많은 것들이 영향을 받게 되면 그때는 써볼만 할 것이라 했다.
여기서 캐싱으로 인해서 다시 메모리를 읽는 시간을 많이 줄일 수 있기 때문에,
단순히 알고리즘 수행 시간으로 계산한 것보다도 더 빨라질 수 있겠다는 이야기를 언급했다.

### 느낀 점
* 아 젠장 떨어질 듯..
* 평소에 ps 말고도 C++을 자주 사용해야겠다.
* ps가 이렇게 해롭습니다(?)
* 공부 좀 더 많이 할걸...
