---
title: '국지 최소값 찾기, 모음 뒤집기'
date: 2017-02-26 22:05:24
tags:
- google
- ps
- interview
categories: google
---

> 면접일: 2/17
> 구글 최승연님

## 문제 1

숫자의 배열이 들어올 때, 다음의 정의에 부합하는 국지 최소값을 구하는 함수를 짜라.

1. 양 옆에 숫자가 있는 경우, 그 두 숫자보다 값이 작다
1. 맨 끝에 있는 경우, 한 쪽에 있는 숫자보다 값이 작다
<!-- more -->

### 내 풀이

* 앞에서부터 숫자를 읽으면서 양 옆 값이랑 비교한다:O(n)을 짜는 데에는 성공.
* O(log n)을 짜려다가 고민만 하고 실패.

### 답안

O(logn)

* 증가, 감소, 볼록, 오목 네 가지 케이스만 생각한다.
* 중간 값보다 작은 쪽으로 다시 탐색한다.

## 문제 2

문장이 들어올 때, 문장에 있는 모음들만을 뒤집는다.

예제: "united states" &rarr; "enated stitus"

### 내 풀이

#### naive 풀이

앞에서부터 읽으면서 인덱스와 모음을 각각 벡터에 넣는다.
인덱스를 벡터의 뒤에서부터 빼고, 그 인덱스에 모음 벡터의 앞에서부터 읽은 모음을 집어넣는다.
O(2n) = O(n).
공간은 모음 길이의 두 배를 더 차지하므로, 최대 3n의 공간 차지함.

#### inplace 개선
양 끝에서부터 읽어오면서, left, right 피벗을 둔다.
left 피벗의 문자와 right 피벗의 문자가 모두 모음이 되도록 각각 한칸씩 움직인다.
둘 다 모음이 될 때 자리를 바꾸고, 다시 한 칸씩 가운데로 움직이게 한다.
left >= right 이면 종료.

## comment

### 고칠 점
* 전역변수 선언 하지 말고, 함수에서 값 받는다고 해주세요. 
(면접관에 따라서 전역변수 괜찮다고 할 수 있음.)
* 함수 이름을 f라고 하지 마세요: 최소한 뭘 하는 함수인지 보이게 해주세요.
* 엣지 케이스를 고려하세요: 하나짜리 배열인 경우를 처리하지 못하고 있습니다. 
모든 것이 같은 경우에도 안 돼요.
* 문제 2에서는 모음인 경우를 찾아서 피벗을 바꾸는 것보다, 자음이면 증가시키는게 더 직관적이지 않겠냐고 하심.

### 좋은 점
* 인덱스 계산이 헷갈릴 수 있는데 잘 하셨어요.

### 팁
* 말을 열심히 하세요.
* 모르겠으면 일단 비효율적인 알고리즘이라도 짜세요.
최적해를 내놓으면 좋겠지만, 코드가 없으면 아무것도 평가할 수 없습니다.


